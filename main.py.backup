# 1. Imports systÃ¨me (DOIVENT ÃŠTRE EN PREMIER)
import os
import sys
import logging
import json

# 1. Configuration Streamlit
import streamlit as st
st.set_page_config(
page_title="Trading Bot Ultimate v4",
page_icon="ğŸ“ˆ",
layout="wide",
initial_sidebar_state="expanded"
)

# 2. Configuration environnement
os.environ['STREAMLIT_HIDE_PYTORCH_WARNING'] = '1'
os.environ['CURRENT_TIME'] = "2025-06-09 01:29:52"  # Mise Ã  jour du timestamp
os.environ['CURRENT_USER'] = "Patmoorea"

# 3. Configuration asyncio et event loop
import asyncio
import nest_asyncio
from asyncio import AbstractEventLoop

def setup_event_loop() -> AbstractEventLoop:
    """Configure l'event loop pour Streamlit"""
        try:
            loop = asyncio.get_event_loop()
                except RuntimeError:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    nest_asyncio.apply()
                    return loop

                    # 5. Imports standards
                    from datetime import datetime
                    import numpy as np
                    import ccxt
                    from dotenv import load_dotenv

                    # 6. Setup de l'event loop avant les imports PyTorch
                    setup_event_loop()

                    # 7. Imports ML/AI
                    import gymnasium as gym
                    from gymnasium import spaces
                    import torch
                    import pandas as pd

                    # 8. Configuration des chemins
                    current_dir = os.path.dirname(os.path.abspath(__file__))
                    parent_dir = os.path.dirname(current_dir)
                    sys.path.append(parent_dir)
                    sys.path.append(current_dir)


                    # Ajout des chemins pour les modules
                    current_dir = os.path.dirname(os.path.abspath(__file__))
                    parent_dir = os.path.dirname(current_dir)
                    sys.path.append(parent_dir)
                    sys.path.append(current_dir)

                    # Imports des modules existants
                    from src.data.realtime.websocket.client import MultiStreamManager, StreamConfig
                    from src.core.buffer.circular_buffer import CircularBuffer
                    from src.indicators.advanced.multi_timeframe import MultiTimeframeAnalyzer, TimeframeConfig
                    from src.analysis.indicators.orderflow.orderflow_analysis import OrderFlowAnalysis, OrderFlowConfig
                    from src.analysis.indicators.volume.volume_analysis import VolumeAnalysis
                    from src.analysis.indicators.volatility.volatility import VolatilityIndicators
                    from src.ai.cnn_lstm import CNNLSTM
                    from src.ai.ppo_gtrxl import PPOGTrXL
                    from src.ai.hybrid_model import HybridAI
                    from src.risk_management.circuit_breakers import CircuitBreaker
                    from src.risk_management.position_manager import PositionManager
                    from src.core.exchange import ExchangeInterface as Exchange
                    from src.notifications.telegram_bot import TelegramBot
                    from src.regime_detection.hmm_kmeans import MarketRegimeDetector
                    from src.strategies.arbitrage.multi_exchange.arbitrage_scanner import ArbitrageScanner as ArbitrageEngine
                    from src.monitoring.streamlit_ui import TradingDashboard

                    # Imports des indicateurs
                    from src.analysis.technical.advanced.advanced_indicators import AdvancedIndicators
                    from src.analysis.indicators.momentum.momentum import MomentumIndicators
                    from src.analysis.indicators.volatility.volatility import VolatilityIndicators
                    from src.analysis.indicators.volume.volume_analysis import VolumeAnalysis
                    from src.analysis.indicators.orderflow.orderflow_analysis import OrderFlowAnalysis, OrderFlowConfig
                    from src.analysis.indicators.trend.indicators import TrendIndicators

                    # Configuration
                    load_dotenv()
                    config = {
                    "ARBITRAGE": {
                    "exchanges": ["binance", "bitfinex", "kraken"],
                    "min_profit": 0.001,
                    "max_trade_size": 1000,
                    "pairs": ["BTC/USDC", "ETH/USDC"],
                    "timeout": 5,
                    "volume_filter": 1000,
                    "price_check": True,
                    "max_slippage": 0.0005
                    },    "TRADING": {
                    "base_currency": "USDC",
                    "pairs": ["BTC/USDC", "ETH/USDC"],
                    "timeframes": ["1m", "5m", "15m", "1h", "4h", "1d"],
                    "study_period": "7d"
                    },
                    "RISK": {
                    'max_drawdown': 0.05,
                    'daily_stop_loss': 0.02,
                    'position_sizing': 'volatility_based',
                    'circuit_breaker': {
                    'market_crash': True,
                    'liquidity_shock': True,
                    'black_swan': True
                    }
                    },
                    "AI": {
                    "confidence_threshold": 0.75,
                    "min_training_size": 1000,
                    "learning_rate": 0.0001,
                    "batch_size": 32,
                    "n_epochs": 10,
                    "gtrxl_layers": 6,
                    "embedding_dim": 512,
                    "dropout": 0.1,
                    "gradient_clip": 0.5
                    },
                    "INDICATORS": {
                    "trend": {
                    "supertrend": {
                    "period": 10,
                    "multiplier": 3
                    },
                    "ichimoku": {
                    "tenkan": 9,
                    "kijun": 26,
                    "senkou": 52
                    },
                    "ema_ribbon": [5, 10, 20, 50, 100, 200]
                    },
                    "momentum": {
                    "rsi": {
                    "period": 14,
                    "overbought": 70,
                    "oversold": 30
                    },
                    "stoch_rsi": {
                    "period": 14,
                    "k": 3,
                    "d": 3
                    },
                    "macd": {
                    "fast": 12,
                    "slow": 26,
                    "signal": 9
                    }
                    },
                    "volatility": {
                    "bbands": {
                    "period": 20,
                    "std_dev": 2
                    },
                    "keltner": {
                    "period": 20,
                    "atr_mult": 2
                    },
                    "atr": {
                    "period": 14
                    }
                    },
                    "volume": {
                    "vwap": {
                    "anchor": "session"
                    },
                    "obv": {
                    "signal": 20
                    },
                    "volume_profile": {
                    "price_levels": 100
                    }
                    },
                    "orderflow": {
                    "delta": {
                    "window": 100
                    },
                    "cvd": {
                    "smoothing": 20
                    },
                    "imbalance": {
                    "threshold": 0.2
                    }
                    }
                    }
                    }

                    # Initialisation du logging
                    logging.basicConfig(
                    level=logging.INFO,
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                    handlers=[
                    logging.FileHandler('trading_bot.log'),
                    logging.StreamHandler()
                    ]
                    )
                    logger = logging.getLogger(__name__)

class TradingEnv(gym.Env):
    """Environment d'apprentissage par renforcement pour le trading"""

    def __init__(self, trading_pairs, timeframes):
        super().__init__()
        self.trading_pairs = trading_pairs
        self.timeframes = timeframes

        # Espace d'observation: 42 features par paire/timeframe
        self.observation_space = spaces.Box(
        low=-np.inf,
        high=np.inf,
        shape=(len(trading_pairs) * len(timeframes) * 42,),
        dtype=np.float32
        )

        # Espace d'action: allocation par paire entre 0 et 1
        self.action_space = spaces.Box(
        low=0,
        high=1,
        shape=(len(trading_pairs),),
        dtype=np.float32
        )

        # ParamÃ¨tres d'apprentissage
        self.reward_scale = 1.0
        self.position_history = []
        self.done_penalty = -1.0

        # Initialisation des mÃ©triques
        self.metrics = {
        'episode_rewards': [],
        'portfolio_values': [],
        'positions': [],
        'actions': []
        }

    def reset(self, seed=None, options=None):
        super().reset(seed=seed)
        self.state = np.zeros(self.observation_space.shape)
        self.position_history.clear()
        return self.state, {}

    def step(self, action):
        # Validation de l'action
            if not self.action_space.contains(action):
                logger.warning(f"Action invalide: {action}")
                action = np.clip(action, self.action_space.low, self.action_space.high)

                # Calcul de la rÃ©compense
                reward = self._calculate_reward(action)

                # Mise Ã  jour de l'Ã©tat
                self._update_state()

                # VÃ©rification des conditions de fin
                done = self._check_done()
                truncated = False

                # Mise Ã  jour des mÃ©triques
                self._update_metrics(action, reward)

                return self.state, reward, done, truncated, self._get_info()

    def _calculate_reward(self, action):
        """Calcule la rÃ©compense basÃ©e sur le PnL et le risque"""
            try:
                # Calcul du PnL
                pnl = self._calculate_pnl(action)

                # PÃ©nalitÃ© pour le risque
                risk_penalty = self._calculate_risk_penalty(action)

                # Reward final
                reward = (pnl - risk_penalty) * self.reward_scale

                return float(reward)

                    except Exception as e:
                        logger.error(f"Erreur calcul reward: {e}")
                        return 0.0

    def _update_state(self):
        """Mise Ã  jour de l'Ã©tat avec les derniÃ¨res donnÃ©es de marchÃ©"""
            try:
                # Mise Ã  jour des features techniques
                technical_features = self._calculate_technical_features()

                # Mise Ã  jour des features de marchÃ©
                market_features = self._calculate_market_features()

                # Combinaison des features
                self.state = np.concatenate([technical_features, market_features])

                    except Exception as e:
                        logger.error(f"Erreur mise Ã  jour state: {e}")

    def _check_done(self):
        """VÃ©rifie les conditions de fin d'Ã©pisode"""
        # VÃ©rification du stop loss
            if self._check_stop_loss():
                return True

                # VÃ©rification de la durÃ©e max
                    if len(self.position_history) >= self.max_steps:
                        return True

                        return False

    def _update_metrics(self, action, reward):
        """Mise Ã  jour des mÃ©triques de l'Ã©pisode"""
        self.metrics['episode_rewards'].append(reward)
        self.metrics['portfolio_values'].append(self._get_portfolio_value())
        self.metrics['positions'].append(self.position_history[-1])
        self.metrics['actions'].append(action)

    def _get_info(self):
        """Retourne les informations additionnelles"""
        return {
        'portfolio_value': self._get_portfolio_value(),
        'current_positions': self.position_history[-1] if self.position_history else None,
        'metrics': self.metrics
        }

    def render(self):
        """Affichage de l'environnement"""
        # Affichage des mÃ©triques principales
        print(f"\nPortfolio Value: {self._get_portfolio_value():.2f}")
        print(f"Total Reward: {sum(self.metrics['episode_rewards']):.2f}")
        print(f"Number of Trades: {len(self.position_history)}")

class MultiStreamManager:
    def __init__(self, pairs=None, config=None):
        """Initialise le gestionnaire de flux multiples"""
        self.pairs = pairs or []
        self.config = config
        self.exchange = None  # InitialisÃ© plus tard
        self.buffer = CircularBuffer()

    def setup_exchange(self, exchange_id="binance"):
        """Configure l'exchange"""
        self.exchange = Exchange(exchange_id=exchange_id)

class TradingBotM4:
    """Classe principale du bot de trading v4"""
    def __init__(self):
        # RÃ©cupÃ©ration des variables d'environnement
        self.current_user = os.getenv('CURRENT_USER', 'Patmoorea')
        self.current_time = os.getenv('CURRENT_TIME', datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S'))
        self.trading_mode = os.getenv('TRADING_MODE', 'production')

        # Configuration de l'exchange et des streams
        self.stream_config = StreamConfig(
        max_connections=12,
        reconnect_delay=1.0,
        buffer_size=10000
        )

        # Initialisation du MultiStreamManager
        self.websocket = MultiStreamManager(
        pairs=config["TRADING"]["pairs"],
        config=self.stream_config
        )

        # Configuration de l'exchange
        self.websocket.setup_exchange("binance")

        self.buffer = CircularBuffer()
        self.buffer = CircularBuffer()

        # Interface et monitoring
        self.dashboard = TradingDashboard()
        self.current_time = "2025-06-09 03:47:46"
        self.current_user = "Patmoorea"

        # Composants principaux
        self.arbitrage_engine = ArbitrageEngine(
        exchanges=config["ARBITRAGE"]["exchanges"],
        pairs=config["ARBITRAGE"]["pairs"],
        min_profit=config["ARBITRAGE"]["min_profit"],
        max_trade_size=config["ARBITRAGE"]["max_trade_size"],
        timeout=config["ARBITRAGE"]["timeout"],
        volume_filter=config["ARBITRAGE"]["volume_filter"],
        price_check=config["ARBITRAGE"]["price_check"],
        max_slippage=config["ARBITRAGE"]["max_slippage"]
        )
        self.telegram = TelegramBot()

        # IA et analyse
        self.hybrid_model = HybridAI()
        self.env = TradingEnv(
        trading_pairs=config["TRADING"]["pairs"],
        timeframes=config["TRADING"]["timeframes"]
        )

        # Gestionnaires de trading
        self.position_manager = PositionManager(
        account_balance=10000,
        max_positions=5,
        max_leverage=3.0,
        min_position_size=0.001
        )
        self.circuit_breaker = CircuitBreaker(
        crash_threshold=0.1,
        liquidity_threshold=0.5,
        volatility_threshold=0.3
        )
        # Configuration des timeframes et indicateurs
        self.timeframe_config = TimeframeConfig(
        timeframes=config["TRADING"]["timeframes"],
        weights={
        "1m": 0.1, "5m": 0.15, "15m": 0.2,
        "1h": 0.25, "4h": 0.15, "1d": 0.15
        }
        )

        # Initialisation des analyseurs
        self._initialize_analyzers()

    def _initialize_analyzers(self):
        """Initialize all analysis components"""
        # Initialisation des analyseurs
        self.advanced_indicators = AdvancedIndicators()
        self.momentum_indicators = MomentumIndicators()
        self.volatility_indicators = VolatilityIndicators()
        self.volume_analysis = VolumeAnalysis()
        self.orderflow_analysis = OrderFlowAnalysis(
        config=OrderFlowConfig(tick_size=0.1)
        )
        self.trend_indicators = TrendIndicators()

        # Dictionnaire des 42 indicateurs avec leurs mÃ©thodes de calcul
        self.indicators = {
        "trend": {
        "supertrend": self.advanced_indicators.indicators["trend"]["supertrend"],
        "ichimoku": self.trend_indicators.ichimoku,
        "vwma": self.advanced_indicators.indicators["trend"]["vwma"],
        "ema_ribbon": self.advanced_indicators.indicators["trend"]["kama"],
        "parabolic_sar": self.advanced_indicators.indicators["trend"]["psar"],
        "zigzag": self.advanced_indicators.indicators["trend"]["trix"]
        },
        "momentum": {
        "rsi": self.momentum_indicators.rsi,
        "stoch_rsi": self.momentum_indicators.stochastic_rsi,
        "macd": self.momentum_indicators.macd,
        "awesome": self.advanced_indicators.indicators["momentum"]["ao"],
        "momentum": self.advanced_indicators.indicators["momentum"]["williams_r"],
        "tsi": self.advanced_indicators.indicators["momentum"]["cci"]
        },
        "volatility": {
        "bbands": self.volatility_indicators.bollinger_bands,
        "keltner": self.volatility_indicators.keltner_channels,
        "atr": self.volatility_indicators.atr,
        "vix_fix": self.volatility_indicators.volatility_index,
        "natr": self.advanced_indicators.indicators["volatility"]["parkinson"],
        "true_range": self.advanced_indicators.indicators["volatility"]["yang_zhang"]
        },
        "volume": {
        "obv": self.volume_analysis.on_balance_volume,
        "vwap": self.volume_analysis.vwap,
        "acc_dist": self.advanced_indicators.indicators["volume"]["accumulation"],
        "chaikin_money": self.advanced_indicators.indicators["volume"]["cmf"],
        "ease_move": self.advanced_indicators.indicators["volume"]["eom"],
        "volume_profile": self.volume_analysis.volume_profile
        },
        "orderflow": {
        "delta": self.advanced_indicators.indicators["orderflow"]["delta_volume"],
        "cvd": self.advanced_indicators.indicators["orderflow"]["imbalance"],
        "footprint": self.advanced_indicators.indicators["orderflow"]["smart_money_index"],
        "liquidity": self.advanced_indicators.indicators["orderflow"]["liquidity_wave"],
        "imbalance": self.orderflow_analysis.analyze_orderflow,
        "absorption": self.advanced_indicators.indicators["orderflow"]["bid_ask_ratio"]
        }
        }

        # Initialisation des modÃ¨les d'IA
        self.models = {
        "cnn_lstm": CNNLSTM(
        input_size=42,
        hidden_size=256,
        num_layers=3,
        dropout=config["AI"]["dropout"]
        ),
        "ppo_gtrxl": PPOGTrXL(
        state_dim=42 * len(config["TRADING"]["timeframes"]),
        action_dim=len(config["TRADING"]["pairs"]),
        n_layers=config["AI"]["gtrxl_layers"],
        embedding_dim=config["AI"]["embedding_dim"]
        )
        }
        """RÃ©cupÃ¨re les derniÃ¨res donnÃ©es de marchÃ©"""
            try:
                data = {}
                for pair in config["TRADING"]["pairs"]:
                    for timeframe in config["TRADING"]["timeframes"]:
                        data.setdefault(timeframe, {})[pair] = self.buffer.get_latest()
                        return data
                            except Exception as e:
                                logger.error(f"[{datetime.utcnow()}] Erreur get_latest_data: {e}")
                                return None

    async def study_market(self, period="7d"):
        """Analyse initiale du marchÃ©"""
        logger.info("ğŸ”Š Ã‰tude du marchÃ© en cours...")
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                # RÃ©cupÃ©ration des donnÃ©es historiques
                historical_data = await self.exchange.get_historical_data(
                config["TRADING"]["pairs"],
                config["TRADING"]["timeframes"],
                period
                )

                # Analyse des indicateurs par timeframe
                indicators_analysis = {}
                for timeframe in config["TRADING"]["timeframes"]:
                    tf_data = historical_data[timeframe]
                        try:
                            result = self.advanced_indicators.analyze_timeframe(tf_data, timeframe)
                            indicators_analysis[timeframe] = {
                            "trend": {"trend_strength": 0},
                            "volatility": {"current_volatility": 0},
                            "volume": {"volume_profile": {"strength": "N/A"}},
                            "dominant_signal": "Neutre"
                            } if result is None else result
                                except Exception as e:
                                    logger.error(f"[{current_time}] Erreur analyse {timeframe}: {e}")

                                    # DÃ©tection du rÃ©gime de marchÃ©
                                    regime = self.regime_detector.predict(indicators_analysis)
                                    logger.info(f"ğŸ”ˆ RÃ©gime de marchÃ© dÃ©tectÃ©: {regime}")

                                    # GÃ©nÃ©ration et envoi du rapport
                                    analysis_report = self._generate_analysis_report(
                                    indicators_analysis,
                                    regime,
                                    current_time=current_time
                                    )
                                    await self.telegram.send_message(analysis_report)

                                    # Mise Ã  jour du dashboard
                                    self.dashboard.update_market_analysis(
                                    historical_data=historical_data,
                                    indicators=indicators_analysis,
                                    regime=regime,
                                    timestamp=current_time
                                    )

                                    return regime, historical_data, indicators_analysis

                                        except Exception as e:
                                            logger.error(f"[{current_time}] Erreur lors de l'Ã©tude du marchÃ©: {str(e)}")
                                            raise

    async def analyze_signals(self, market_data, indicators):
        """Analyse technique et fondamentale avancÃ©e"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                # VÃ©rification des donnÃ©es
                    if market_data is None or indicators is None:
                        logger.warning(f"[{current_time}] DonnÃ©es manquantes pour l'analyse")
                        return None

                        # Utilisation du modÃ¨le hybride pour l'analyse technique
                        technical_features = self.hybrid_model.analyze_technical(
                        market_data=market_data,
                        indicators=indicators,
                        timestamp=current_time
                        )

                        # Normalisation si nÃ©cessaire
                            if not isinstance(technical_features, dict):
                                technical_features = {
                                'tensor': technical_features,
                                'score': float(torch.mean(technical_features).item())
                                }

                                # Analyse des news via FinBERT custom
                                news_impact = await self.news_analyzer.analyze_recent_news(
                                timestamp=current_time
                                )

                                # DÃ©tection du rÃ©gime de marchÃ© via HMM + K-Means
                                current_regime = self.regime_detector.detect_regime(
                                indicators,
                                timestamp=current_time
                                )

                                # Combinaison des features pour le GTrXL
                                combined_features = self._combine_features(
                                technical_features,
                                news_impact,
                                current_regime
                                )

                                # DÃ©cision via PPO+GTrXL (6 couches, 512 embeddings)
                                policy, value = self.decision_model(
                                combined_features,
                                timestamp=current_time
                                )

                                # Construction de la dÃ©cision finale
                                decision = self._build_decision(
                                policy=policy,
                                value=value,
                                technical_score=technical_features['score'],
                                news_sentiment=news_impact['sentiment'],
                                regime=current_regime,
                                timestamp=current_time
                                )

                                # Ajout de la gestion des risques
                                decision = self._add_risk_management(
                                decision,
                                timestamp=current_time
                                )

                                # Log de la dÃ©cision
                                logger.info(
                                f"[{current_time}] DÃ©cision gÃ©nÃ©rÃ©e - "
                                f"Action: {decision['action']}, "
                                f"Confiance: {decision['confidence']:.2%}, "
                                f"RÃ©gime: {decision['regime']}"
                                )

                                return decision

                                    except Exception as e:
                                        logger.error(f"[{current_time}] Erreur analyse signaux: {e}")
                                        await self.telegram.send_message(
                                        f"âš ï¸ Erreur analyse: {str(e)}\n"
                                        f"Date: {current_time} UTC\n"
                                        f"Trader: {self.current_user}"
                                        )
                                        return None

    def _build_decision(self, policy, value, technical_score, news_sentiment, regime, timestamp):
        """Construit la dÃ©cision finale basÃ©e sur tous les inputs"""
            try:
                # Conversion policy en numpy pour le traitement
                policy_np = policy.detach().numpy()

                # Ne garder que les actions d'achat (long only)
                buy_actions = np.maximum(policy_np, 0)

                # Calculer la confiance basÃ©e sur value et les scores
                confidence = float(np.mean([
                float(value.detach().numpy()),
                technical_score,
                news_sentiment['score']
                ]))

                # Trouver le meilleur actif Ã  acheter
                best_pair_idx = np.argmax(buy_actions)

                # Construire la dÃ©cision
                decision = {
                "action": "buy" if confidence > config["AI"]["confidence_threshold"] else "wait",
                "symbol": config["TRADING"]["pairs"][best_pair_idx],
                "confidence": confidence,
                "timestamp": timestamp,
                "regime": regime,
                "technical_score": technical_score,
                "news_impact": news_sentiment['sentiment'],
                "value_estimate": float(value.detach().numpy()),
                "position_size": buy_actions[best_pair_idx]
                }

                return decision

                    except Exception as e:
                        logger.error(f"[{timestamp}] Erreur construction dÃ©cision: {e}")
                        return None
    def _combine_features(self, technical_features, news_impact, regime):
        """Combine toutes les features pour le GTrXL"""
            try:
                # Conversion en tensors
                technical_tensor = technical_features['tensor']
                news_tensor = torch.tensor(news_impact['embeddings'], dtype=torch.float32)
                regime_tensor = torch.tensor(self._encode_regime(regime), dtype=torch.float32)

                # Ajout de dimensions si nÃ©cessaire
                    if news_tensor.dim() == 1:
                        news_tensor = news_tensor.unsqueeze(0)
                            if regime_tensor.dim() == 1:
                                regime_tensor = regime_tensor.unsqueeze(0)

                                # Combinaison
                                features = torch.cat([
                                technical_tensor,
                                news_tensor,
                                regime_tensor
                                ], dim=-1)

                                return features

                                    except Exception as e:
                                        logger.error(f"[2025-06-06 07:40:42] Erreur lors de la combinaison des features: {e}")
                                        raise

    def _encode_regime(self, regime):
        """Encode le rÃ©gime de marchÃ© en vecteur"""
        regime_mapping = {
        'High Volatility Bull': [1, 0, 0, 0, 0],
        'Low Volatility Bull': [0, 1, 0, 0, 0],
        'High Volatility Bear': [0, 0, 1, 0, 0],
        'Low Volatility Bear': [0, 0, 0, 1, 0],
        'Sideways': [0, 0, 0, 0, 1]
        }
        return regime_mapping.get(regime, [0, 0, 0, 0, 0])

    async def execute_trades(self, decision):
        """ExÃ©cution des trades selon la dÃ©cision"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

        # VÃ©rification du circuit breaker
            if await self.circuit_breaker.should_stop_trading():
                logger.warning(f"[{current_time}] ğŸ›‘ Circuit breaker activÃ© - Trading suspendu")
                await self.telegram.send_message(
                "âš ï¸ Trading suspendu: Circuit breaker activÃ©\n"
                f"Date: {current_time} UTC\n"
                f"Trader: {self.current_user}"
                )
                return

                if decision and decision["confidence"] > config["AI"]["confidence_threshold"]:
                        try:
                            # VÃ©rification des opportunitÃ©s d'arbitrage
                            arb_ops = await self.arbitrage_engine.find_opportunities()
                                if arb_ops:
                                    await self.telegram.send_message(
                                    f"ğŸ’° OpportunitÃ© d'arbitrage dÃ©tectÃ©e:\n"
                                    f"Date: {current_time} UTC\n"
                                    f"Trader: {self.current_user}\n"
                                    f"Details: {arb_ops}"
                                    )

                                    # RÃ©cupÃ©ration du prix actuel
                                    current_price = await self.exchange.get_price(decision["symbol"])
                                    decision["entry_price"] = current_price

                                    # Calcul de la taille de position avec gestion du risque
                                    position_size = self.position_manager.calculate_position_size(
                                    decision,
                                    available_balance=await self.exchange.get_balance(config["TRADING"]["base_currency"])
                                    )

                                    # VÃ©rification finale avant l'ordre
                                        if not self._validate_trade(decision, position_size):
                                            logger.warning(f"[{current_time}] Trade invalidÃ© par les vÃ©rifications finales")
                                            return

                                        # Placement de l'ordre avec stop loss
                                        order = await self.exchange.create_order(
                                        symbol=decision["symbol"],
                                        type="limit",
                                        side="buy",  # Achat uniquement comme demandÃ©
                                        amount=position_size,
                                        price=decision["entry_price"],
                                        params={
                                        "stopLoss": {
                                        "type": "trailing",
                                        "activation_price": decision["trailing_stop"]["activation_price"],
                                        "callback_rate": decision["trailing_stop"]["callback_rate"]
                                        },
                                        "takeProfit": {
                                        "price": decision["take_profit"]
                                        }
                                        }
                                        )

                                        # Notification Telegram dÃ©taillÃ©e
                                        await self.telegram.send_message(
                                        f"ğŸ“„ Ordre placÃ©:\n"
                                        f"Date: {current_time} UTC\n"
                                        f"Trader: {self.current_user}\n"
                                        f"Symbol: {order['symbol']}\n"
                                        f"Type: {order['type']}\n"
                                        f"Prix: {order['price']}\n"
                                        f"Stop Loss: {decision['stop_loss']}\n"
                                        f"Take Profit: {decision['take_profit']}\n"
                                        f"Trailing Stop: {decision['trailing_stop']['activation_price']}\n"
                                        f"Confiance: {decision['confidence']:.2%}\n"
                                        f"RÃ©gime: {decision['regime']}\n"
                                        f"News Impact: {decision['news_impact']}\n"
                                        f"Volume: {position_size} {config['TRADING']['base_currency']}"
                                        )

                                        # Mise Ã  jour du dashboard
                                        self.dashboard.update_trades(order)

                                            except Exception as e:
                                                logger.error(f"[{current_time}] Erreur lors de l'exÃ©cution: {e}")
                                                await self.telegram.send_message(
                                                f"âš ï¸ Erreur d'exÃ©cution: {str(e)}\n"
                                                f"Date: {current_time} UTC\n"
                                                f"Trader: {self.current_user}"
                                                )

    def _validate_trade(self, decision, position_size):
        """Validation finale avant l'exÃ©cution du trade"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                # VÃ©rification de la taille minimale
                    if position_size < 0.001:  # Exemple de taille minimale
                    logger.warning(f"[{current_time}] Taille de position trop petite")
                    return False

                    # VÃ©rification du spread
                        if self._check_spread_too_high(decision["symbol"]):
                            logger.warning(f"[{current_time}] Spread trop important")
                            return False

                            # VÃ©rification de la liquiditÃ©
                                if not self._check_sufficient_liquidity(decision["symbol"], position_size):
                                    logger.warning(f"[{current_time}] LiquiditÃ© insuffisante")
                                    return False

                                    # VÃ©rification des news Ã  haut risque
                                        if self._check_high_risk_news():
                                            logger.warning(f"[{current_time}] News Ã  haut risque dÃ©tectÃ©es")
                                            return False

                                            # VÃ©rification des limites de position
                                                if not self.position_manager.check_position_limits(position_size):
                                                    logger.warning(f"[{current_time}] Limites de position dÃ©passÃ©es")
                                                    return False

                                                    # VÃ©rification du timing d'entrÃ©e
                                                        if not self._check_entry_timing(decision):
                                                            logger.warning(f"[{current_time}] Timing d'entrÃ©e non optimal")
                                                            return False

                                                            return True

                                                                except Exception as e:
                                                                    logger.error(f"[{current_time}] Erreur lors de la validation du trade: {e}")
                                                                    return False

    def _check_spread_too_high(self, symbol):
        """VÃ©rifie si le spread est trop important"""
            try:
                orderbook = self.buffer.get_orderbook(symbol)
                best_bid = orderbook['bids'][0][0]
                best_ask = orderbook['asks'][0][0]

                spread = (best_ask - best_bid) / best_bid
                return spread > 0.001  # 0.1% spread maximum

                    except Exception as e:
                        logger.error(f"[2025-06-06 07:40:42] Erreur vÃ©rification spread: {e}")
                        return True  # Par sÃ©curitÃ©

    def _check_sufficient_liquidity(self, symbol, position_size):
        """VÃ©rifie s'il y a assez de liquiditÃ© pour le trade"""
            try:
                orderbook = self.buffer.get_orderbook(symbol)

                # Calcul de la profondeur de marchÃ© nÃ©cessaire
                required_liquidity = position_size * 3  # 3x la taille pour la sÃ©curitÃ©

                # Somme de la liquiditÃ© disponible
                available_liquidity = sum(vol for _, vol in orderbook['bids'][:10])

                return available_liquidity >= required_liquidity

                    except Exception as e:
                        logger.error(f"[2025-06-06 07:40:42] Erreur vÃ©rification liquiditÃ©: {e}")
                        return False

    def _check_entry_timing(self, decision):
        """VÃ©rifie si le timing d'entrÃ©e est optimal"""
            try:
                # VÃ©rification des signaux de momentum
                momentum_signals = self._analyze_momentum_signals()
                    if momentum_signals["strength"] < 0.5:
                        return False

                        # VÃ©rification de la volatilitÃ©
                        volatility = self._analyze_volatility()
                            if volatility["current"] > volatility["threshold"]:
                                return False

                                # VÃ©rification du volume
                                volume_analysis = self._analyze_volume_profile()
                                    if not volume_analysis["supports_entry"]:
                                        return False

                                        return True

                                            except Exception as e:
                                                logger.error(f"[2025-06-06 07:40:42] Erreur vÃ©rification timing: {e}")
                                                return False

    def _analyze_momentum_signals(self):
        """Analyse des signaux de momentum"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                signals = {
                "rsi": self._calculate_rsi(self.buffer.get_latest()),
                "macd": self._calculate_macd(self.buffer.get_latest()),
                "stoch": self._calculate_stoch_rsi(self.buffer.get_latest())
                }

                # Calcul de la force globale
                strengths = []
                    if signals["rsi"]:
                        strengths.append(abs(signals["rsi"]["strength"]))
                            if signals["macd"]:
                                strengths.append(abs(signals["macd"]["strength"]))
                                    if signals["stoch"]:
                                        strengths.append(abs(signals["stoch"]["strength"]))

                                        return {
                                        "signals": signals,
                                        "strength": np.mean(strengths) if strengths else 0,
                                        "timestamp": current_time
                                        }

                                            except Exception as e:
                                                logger.error(f"[{current_time}] Erreur analyse momentum: {e}")
                                                return {"strength": 0, "timestamp": current_time}

    def _analyze_volatility(self):
        """Analyse de la volatilitÃ© actuelle"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                # Calcul des indicateurs de volatilitÃ©
                bbands = self._calculate_bbands(self.buffer.get_latest())
                atr = self._calculate_atr(self.buffer.get_latest())

                # Calcul de la volatilitÃ© normalisÃ©e
                current_volatility = 0
                    if bbands and atr:
                        bb_width = bbands["bandwidth"]
                        atr_norm = atr["normalized"]
                        current_volatility = (bb_width + atr_norm) / 2

                        return {
                        "current": current_volatility,
                        "threshold": 0.8,  # Seuil dynamique basÃ© sur le rÃ©gime
                        "timestamp": current_time,
                        "indicators": {
                        "bbands": bbands,
                        "atr": atr
                        }
                        }

                            except Exception as e:
                                logger.error(f"[{current_time}] Erreur analyse volatilitÃ©: {e}")
                                return {"current": 1, "threshold": 0, "timestamp": current_time}

    def _analyze_volume_profile(self):
        """Analyse du profil de volume"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                vp = self._calculate_vp(self.buffer.get_latest())

                    if not vp:
                        return {"supports_entry": False, "timestamp": current_time}

                        # Analyse des niveaux de support/rÃ©sistance
                        current_price = self.buffer.get_latest()["close"].iloc[-1]
                        nearest_poc = min(vp["poc"], key=lambda x: abs(x - current_price))

                        # VÃ©rification des conditions d'entrÃ©e
                        price_near_poc = abs(current_price - nearest_poc) / current_price < 0.01
                        volume_increasing = vp["profile"][-1] > np.mean(vp["profile"][-5:])

                        return {
                        "supports_entry": price_near_poc and volume_increasing,
                        "poc": nearest_poc,
                        "volume_trend": "increasing" if volume_increasing else "decreasing",
                        "timestamp": current_time
                        }

                            except Exception as e:
                                logger.error(f"[{current_time}] Erreur analyse volume profile: {e}")
                                return {"supports_entry": False, "timestamp": current_time}

    async def run(self):
        """Boucle principale du bot"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp
        current_user = "Patmoorea"

            try:
                # Banner de dÃ©marrage
                logger.info(f"""
                â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                â•‘                Trading Bot Ultimate v4 Started               â•‘
                â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                â•‘ Time: {current_time} UTC                                    â•‘
                â•‘ User: {current_user}                                        â•‘
                â•‘ Mode: BUY_ONLY                                             â•‘
                â•‘ AI: PPO-GTrXL (6-layer, 512d)                             â•‘
                â•‘ Status: RUNNING                                            â•‘
                â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                """)

                # Ã‰tude initiale du marchÃ©
                regime, historical_data, initial_analysis = await self.study_market(
                config["TRADING"]["study_period"]
                )

                # EntraÃ®nement initial si nÃ©cessaire
                    if self._should_train(historical_data):
                        await self._train_models(historical_data, initial_analysis)

                        while True:
                                try:
                                    # 1. Traitement des donnÃ©es
                                    market_data, indicators = await self.process_market_data()
                                        if market_data is None or indicators is None:
                                            logger.warning(f"[{current_time}] DonnÃ©es manquantes, attente...")
                                            await asyncio.sleep(5)
                                            continue

                                        # 2. VÃ©rification des opportunitÃ©s d'arbitrage
                                        await self.check_arbitrage_opportunities()

                                        # 3. Analyse et dÃ©cision
                                        decision = await self.analyze_signals(market_data, indicators)

                                        # 4. Mise Ã  jour du rÃ©gime de marchÃ© si nÃ©cessaire
                                        current_regime = self.regime_detector.detect_regime(indicators)
                                            if current_regime != regime:
                                                regime = current_regime
                                                logger.info(f"[{current_time}] Changement de rÃ©gime dÃ©tectÃ©: {regime}")
                                                await self.telegram.send_message(
                                                f"ğŸ”ˆ Changement de rÃ©gime dÃ©tectÃ©!\n"
                                                f"Date: {current_time} UTC\n"
                                                f"Nouveau rÃ©gime: {regime}"
                                                )

                                                # 5. ExÃ©cution si nÃ©cessaire
                                                    if decision and decision.get('action') == 'buy':
                                                        await self.execute_trades(decision)

                                                        # 6. Mise Ã  jour du dashboard
                                                        self.dashboard.update_status({
                                                        'time': current_time,
                                                        'user': current_user,
                                                        'regime': regime,
                                                        'last_decision': decision,
                                                        'performance_metrics': self._calculate_performance_metrics()
                                                        })

                                                        # 7. VÃ©rification des conditions d'arrÃªt
                                                            if await self._should_stop_trading():
                                                                logger.info(f"[{current_time}] Conditions d'arrÃªt atteintes")
                                                                break

                                                            # Attente avant la prochaine itÃ©ration
                                                            await asyncio.sleep(1)

                                                                except KeyboardInterrupt:
                                                                    logger.info(f"[{current_time}] âŒ ArrÃªt manuel demandÃ©")
                                                                    await self.telegram.send_message(
                                                                    f"ğŸ›‘ Bot arrÃªtÃ© manuellement\n"
                                                                    f"Date: {current_time} UTC\n"
                                                                    f"User: {current_user}"
                                                                    )
                                                                    break

                                                                    except Exception as e:
                                                                        logger.error(f"[{current_time}] Erreur critique: {e}")
                                                                        await self.telegram.send_message(
                                                                        f"ğŸš¨ Erreur critique: {str(e)}\n"
                                                                        f"Date: {current_time} UTC\n"
                                                                        f"User: {current_user}"
                                                                        )
                                                                        await asyncio.sleep(5)

                                                                            except Exception as e:
                                                                                logger.error(f"[{current_time}] Erreur fatale: {e}")
                                                                                await self.telegram.send_message(
                                                                                f"ğŸ’€ Erreur fatale - Bot arrÃªtÃ©: {str(e)}\n"
                                                                                f"Date: {current_time} UTC\n"
                                                                                f"User: {current_user}"
                                                                                )
                                                                                raise

    def _should_train(self, historical_data):
        """DÃ©termine si les modÃ¨les doivent Ãªtre rÃ©entraÃ®nÃ©s"""
            try:
                # VÃ©rification de la taille minimale des donnÃ©es
                    if len(historical_data.get('1h', [])) < config["AI"]["min_training_size"]:
                        return False

                        # VÃ©rification de la derniÃ¨re session d'entraÃ®nement
                            if not hasattr(self, 'last_training_time'):
                                return True

                                time_since_training = datetime.utcnow() - self.last_training_time
                                return time_since_training.days >= 1  # RÃ©entraÃ®nement quotidien

                                    except Exception as e:
                                        logger.error(f"[2025-06-07 18:35:54] Erreur vÃ©rification entraÃ®nement: {e}")
                                        return False

    async def _train_models(self, historical_data, initial_analysis):
        """EntraÃ®ne ou met Ã  jour les modÃ¨les"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                logger.info(f"[{current_time}] ğŸ® DÃ©but de l'entraÃ®nement des modÃ¨les...")

                # PrÃ©paration des donnÃ©es d'entraÃ®nement
                X_train, y_train = self._prepare_training_data(
                historical_data,
                initial_analysis
                )

                # EntraÃ®nement du modÃ¨le hybride
                self.hybrid_model.train(
                market_data=historical_data,
                indicators=initial_analysis,
                epochs=config["AI"]["n_epochs"],
                batch_size=config["AI"]["batch_size"],
                learning_rate=config["AI"]["learning_rate"]
                )

                # EntraÃ®nement du PPO-GTrXL
                self.models["ppo_gtrxl"].train(
                env=self.env,
                total_timesteps=100000,
                batch_size=config["AI"]["batch_size"],
                learning_rate=config["AI"]["learning_rate"],
                gradient_clip=config["AI"]["gradient_clip"]
                )

                # EntraÃ®nement du CNN-LSTM
                self.models["cnn_lstm"].train(
                X_train,
                y_train,
                epochs=config["AI"]["n_epochs"],
                batch_size=config["AI"]["batch_size"],
                validation_split=0.2
                )

                # Mise Ã  jour du timestamp d'entraÃ®nement
                self.last_training_time = datetime.utcnow()

                # Sauvegarde des modÃ¨les
                self._save_models()

                logger.info(f"[{current_time}] âœ… EntraÃ®nement terminÃ© avec succÃ¨s")

                    except Exception as e:
                        logger.error(f"[{current_time}] âŒ Erreur lors de l'entraÃ®nement: {e}")
                        raise

    def _prepare_training_data(self, historical_data, initial_analysis):
        """PrÃ©pare les donnÃ©es pour l'entraÃ®nement"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                features = []
                labels = []

                # Pour chaque timeframe
                for timeframe in config["TRADING"]["timeframes"]:
                    tf_data = historical_data[timeframe]
                    tf_analysis = initial_analysis[timeframe]

                    # Extraction des features
                    technical_features = self._extract_technical_features(tf_data)
                    market_features = self._extract_market_features(tf_data)
                    indicator_features = self._extract_indicator_features(tf_analysis)

                    # Combinaison des features
                    combined_features = np.concatenate([
                    technical_features,
                    market_features,
                    indicator_features
                    ], axis=1)

                    features.append(combined_features)

                    # CrÃ©ation des labels (returns futurs)
                    future_returns = self._calculate_future_returns(tf_data)
                    labels.append(future_returns)

                    # Fusion des donnÃ©es de diffÃ©rents timeframes
                    X = np.concatenate(features, axis=1)
                    y = np.mean(labels, axis=0)

                    return X, y

                        except Exception as e:
                            logger.error(f"[{current_time}] Erreur prÃ©paration donnÃ©es: {e}")
                            raise

    def _extract_technical_features(self, data):
        """Extrait les features techniques des donnÃ©es"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                features = []

                # Features de tendance
                    if trend_data := self._calculate_trend_features(data):
                        features.append(trend_data)

                        # Features de momentum
                            if momentum_data := self._calculate_momentum_features(data):
                                features.append(momentum_data)

                                # Features de volatilitÃ©
                                    if volatility_data := self._calculate_volatility_features(data):
                                        features.append(volatility_data)

                                        # Features de volume
                                            if volume_data := self._calculate_volume_features(data):
                                                features.append(volume_data)

                                                # Features d'orderflow
                                                    if orderflow_data := self._calculate_orderflow_features(data):
                                                        features.append(orderflow_data)

                                                        return np.concatenate(features, axis=1)

                                                            except Exception as e:
                                                                logger.error(f"[{current_time}] Erreur extraction features techniques: {e}")
                                                                return np.array([])

    def _extract_market_features(self, data):
        """Extrait les features de marchÃ©"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                features = []

                # Prix relatifs
                close = data['close'].values
                features.append(close[1:] / close[:-1] - 1)  # Returns

                # Volumes relatifs
                volume = data['volume'].values
                features.append(volume[1:] / volume[:-1] - 1)  # Volume change

                # Spread
                features.append((data['high'] - data['low']) / data['close'])

                # Gap analysis
                features.append(self._calculate_gap_features(data))

                # LiquiditÃ©
                features.append(self._calculate_liquidity_features(data))

                return np.column_stack(features)

                    except Exception as e:
                        logger.error(f"[{current_time}] Erreur extraction features marchÃ©: {e}")
                        return np.array([])

    def _extract_indicator_features(self, analysis):
        """Extrait les features des indicateurs"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                features = []

                # Features de tendance
                    if "trend" in analysis:
                        trend_strength = analysis["trend"].get("trend_strength", 0)
                        features.append(trend_strength)

                        # Features de volatilitÃ©
                            if "volatility" in analysis:
                                volatility = analysis["volatility"].get("current_volatility", 0)
                                features.append(volatility)

                                # Features de volume
                                    if "volume" in analysis:
                                        volume_profile = analysis["volume"].get("volume_profile", {})
                                        strength = float(volume_profile.get("strength", 0))
                                        features.append(strength)

                                        # Signal dominant
                                            if "dominant_signal" in analysis:
                                                signal_mapping = {
                                                "Bullish": 1,
                                                "Bearish": -1,
                                                "Neutral": 0
                                                }
                                                signal = signal_mapping.get(analysis["dominant_signal"], 0)
                                                features.append(signal)

                                                return np.array(features)

                                                    except Exception as e:
                                                        logger.error(f"[{current_time}] Erreur extraction features indicateurs: {e}")
                                                        return np.array([])
    def _calculate_trend_features(self, data):
        """Calcule les features de tendance"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                features = []

                # Supertrend
                    if st_data := self._calculate_supertrend(data):
                        features.append(st_data["value"])
                        features.append(st_data["direction"])
                        features.append(st_data["strength"])

                        # Ichimoku
                            if ichi_data := self._calculate_ichimoku(data):
                                features.append(ichi_data["tenkan"] / data["close"])
                                features.append(ichi_data["kijun"] / data["close"])
                                features.append(ichi_data["senkou_a"] / data["close"])
                                features.append(ichi_data["senkou_b"] / data["close"])
                                features.append(ichi_data["cloud_strength"])

                                # EMA Ribbon
                                    if ema_data := self._calculate_ema_ribbon(data):
                                        features.append(ema_data["trend"])
                                        features.append(ema_data["strength"])
                                        for ema in ema_data["emas"].values():
                                            features.append(ema / data["close"])

                                            # Parabolic SAR
                                                if psar_data := self._calculate_psar(data):
                                                    features.append(psar_data["value"] / data["close"])
                                                    features.append(psar_data["trend"])
                                                    features.append(psar_data["strength"])

                                                    return np.column_stack(features)

                                                        except Exception as e:
                                                            logger.error(f"[{current_time}] Erreur calcul features tendance: {e}")
                                                            return np.array([])

    def _calculate_momentum_features(self, data):
        """Calcule les features de momentum"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                features = []

                # RSI
                    if rsi_data := self._calculate_rsi(data):
                        features.append(rsi_data["value"])
                        features.append(float(rsi_data["overbought"]))
                        features.append(float(rsi_data["oversold"]))
                        features.append(rsi_data["divergence"])

                        # Stochastic RSI
                            if stoch_data := self._calculate_stoch_rsi(data):
                                features.append(stoch_data["k_line"])
                                features.append(stoch_data["d_line"])
                                features.append(float(stoch_data["overbought"]))
                                features.append(float(stoch_data["oversold"]))
                                features.append(stoch_data["crossover"])

                                # MACD
                                    if macd_data := self._calculate_macd(data):
                                        features.append(macd_data["macd"])
                                        features.append(macd_data["signal"])
                                        features.append(macd_data["histogram"])
                                        features.append(macd_data["crossover"])
                                        features.append(macd_data["strength"])

                                        # Awesome Oscillator
                                            if ao_data := self._calculate_ao(data):
                                                features.append(ao_data["value"])
                                                features.append(ao_data["momentum_shift"])
                                                features.append(ao_data["strength"])
                                                features.append(float(ao_data["zero_cross"]))

                                                # TSI
                                                    if tsi_data := self._calculate_tsi(data):
                                                        features.append(tsi_data["tsi"])
                                                        features.append(tsi_data["signal"])
                                                        features.append(tsi_data["histogram"])
                                                        features.append(tsi_data["divergence"])

                                                        return np.column_stack(features)

                                                            except Exception as e:
                                                                logger.error(f"[{current_time}] Erreur calcul features momentum: {e}")
                                                                return np.array([])

    def _calculate_volatility_features(self, data):
        """Calcule les features de volatilitÃ©"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                features = []

                # Bollinger Bands
                    if bb_data := self._calculate_bbands(data):
                        features.append((bb_data["upper"] - data["close"]) / data["close"])
                        features.append((bb_data["middle"] - data["close"]) / data["close"])
                        features.append((bb_data["lower"] - data["close"]) / data["close"])
                        features.append(bb_data["bandwidth"])
                        features.append(bb_data["percent_b"])
                        features.append(float(bb_data["squeeze"]))

                        # Keltner Channels
                            if kc_data := self._calculate_keltner(data):
                                features.append((kc_data["upper"] - data["close"]) / data["close"])
                                features.append((kc_data["middle"] - data["close"]) / data["close"])
                                features.append((kc_data["lower"] - data["close"]) / data["close"])
                                features.append(kc_data["width"])
                                features.append(kc_data["position"])

                                # ATR
                                    if atr_data := self._calculate_atr(data):
                                        features.append(atr_data["value"])
                                        features.append(atr_data["normalized"])
                                        features.append(atr_data["trend"])
                                        features.append(atr_data["volatility_regime"])

                                        # VIX Fix
                                            if vix_data := self._calculate_vix_fix(data):
                                                features.append(vix_data["value"])
                                                features.append(vix_data["regime"])
                                                features.append(vix_data["trend"])
                                                features.append(vix_data["percentile"])

                                                return np.column_stack(features)

                                                    except Exception as e:
                                                        logger.error(f"[{current_time}] Erreur calcul features volatilitÃ©: {e}")
                                                        return np.array([])

    def _calculate_gap_features(self, data):
        """Calcule les features de gaps"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                features = []

                # Prix d'ouverture vs clÃ´ture prÃ©cÃ©dente
                open_close_gap = (data["open"] - data["close"].shift(1)) / data["close"].shift(1)
                features.append(open_close_gap)

                # Gap haussier/baissier
                features.append(np.where(open_close_gap > 0, 1, -1))

                # Force du gap
                features.append(abs(open_close_gap))

                # Gap comblÃ©
                gap_filled = (data["low"] <= data["close"].shift(1)) & (data["high"] >= data["open"])
                features.append(gap_filled.astype(float))

                return np.column_stack(features)

                    except Exception as e:
                        logger.error(f"[{current_time}] Erreur calcul features gaps: {e}")
                        return np.array([])
    def _calculate_liquidity_features(self, data):
        """Calcule les features de liquiditÃ©"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                features = []

                # Analyse du carnet d'ordres
                    if orderbook := self.buffer.get_orderbook(data.name):
                        # DÃ©sÃ©quilibre bid/ask
                        bid_volume = sum(vol for _, vol in orderbook["bids"][:10])
                        ask_volume = sum(vol for _, vol in orderbook["asks"][:10])
                        imbalance = (bid_volume - ask_volume) / (bid_volume + ask_volume)
                        features.append(imbalance)

                        # Profondeur de marchÃ©
                        depth = (bid_volume + ask_volume) / data["volume"].mean()
                        features.append(depth)

                        # Spread relatif
                        spread = (orderbook["asks"][0][0] - orderbook["bids"][0][0]) / orderbook["bids"][0][0]
                        features.append(spread)

                        # Clusters de liquiditÃ©
                        clusters = self._detect_liquidity_clusters(orderbook)
                        features.append(len(clusters["bid_clusters"]))
                        features.append(len(clusters["ask_clusters"]))

                        # Score de rÃ©sistance Ã  l'impact
                        impact_resistance = self._calculate_impact_resistance(orderbook)
                        features.append(impact_resistance)

                        # MÃ©triques historiques
                        # Volume moyen sur 24h
                        vol_24h = data["volume"].rolling(window=1440).mean()  # 1440 minutes = 24h
                        features.append(data["volume"] / vol_24h)

                        # Ratio de liquiditÃ© de Amihud
                        daily_returns = data["close"].pct_change()
                        amihud = abs(daily_returns) / (data["volume"] * data["close"])
                        features.append(amihud)

                        # Ratio de turnover
                        turnover = data["volume"] * data["close"] / data["volume"].rolling(window=20).mean()
                        features.append(turnover)

                        return np.column_stack(features)

                            except Exception as e:
                                logger.error(f"[{current_time}] Erreur calcul features liquiditÃ©: {e}")
                                return np.array([])

    def _detect_liquidity_clusters(self, orderbook):
        """DÃ©tecte les clusters de liquiditÃ© dans le carnet d'ordres"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                bid_clusters = []
                ask_clusters = []

                # ParamÃ¨tres de clustering
                min_volume = 1.0  # Volume minimum pour un cluster
                price_threshold = 0.001  # Distance maximale entre prix pour un mÃªme cluster

                # DÃ©tection des clusters cÃ´tÃ© bid
                current_cluster = {"start_price": None, "total_volume": 0}
                for price, volume in orderbook["bids"]:
                        if volume >= min_volume:
                                if current_cluster["start_price"] is None:
                                    current_cluster = {"start_price": price, "total_volume": volume}
                                        elif abs(price - current_cluster["start_price"]) <= price_threshold:
                                            current_cluster["total_volume"] += volume
                                                else:
                                                        if current_cluster["total_volume"] >= min_volume:
                                                            bid_clusters.append(current_cluster)
                                                            current_cluster = {"start_price": price, "total_volume": volume}

                                                            # DÃ©tection des clusters cÃ´tÃ© ask
                                                            current_cluster = {"start_price": None, "total_volume": 0}
                                                            for price, volume in orderbook["asks"]:
                                                                    if volume >= min_volume:
                                                                            if current_cluster["start_price"] is None:
                                                                                current_cluster = {"start_price": price, "total_volume": volume}
                                                                                    elif abs(price - current_cluster["start_price"]) <= price_threshold:
                                                                                        current_cluster["total_volume"] += volume
                                                                                            else:
                                                                                                    if current_cluster["total_volume"] >= min_volume:
                                                                                                        ask_clusters.append(current_cluster)
                                                                                                        current_cluster = {"start_price": price, "total_volume": volume}

                                                                                                        return {
                                                                                                        "bid_clusters": bid_clusters,
                                                                                                        "ask_clusters": ask_clusters,
                                                                                                        "timestamp": current_time
                                                                                                        }

                                                                                                            except Exception as e:
                                                                                                                logger.error(f"[{current_time}] Erreur dÃ©tection clusters: {e}")
                                                                                                                return {"bid_clusters": [], "ask_clusters": [], "timestamp": current_time}

    def _calculate_impact_resistance(self, orderbook, impact_size=1.0):
        """Calcule la rÃ©sistance Ã  l'impact de marchÃ©"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                # Calcul de l'impact sur les bids
                cumulative_bid_volume = 0
                bid_impact = 0
                for price, volume in orderbook["bids"]:
                    cumulative_bid_volume += volume
                        if cumulative_bid_volume >= impact_size:
                            bid_impact = (orderbook["bids"][0][0] - price) / orderbook["bids"][0][0]
                            break

                        # Calcul de l'impact sur les asks
                        cumulative_ask_volume = 0
                        ask_impact = 0
                        for price, volume in orderbook["asks"]:
                            cumulative_ask_volume += volume
                                if cumulative_ask_volume >= impact_size:
                                    ask_impact = (price - orderbook["asks"][0][0]) / orderbook["asks"][0][0]
                                    break

                                # Score de rÃ©sistance
                                resistance_score = 1 / (bid_impact + ask_impact) if (bid_impact + ask_impact) > 0 else float('inf')

                                return resistance_score

                                    except Exception as e:
                                        logger.error(f"[{current_time}] Erreur calcul rÃ©sistance impact: {e}")
                                        return 0.0

    def _calculate_future_returns(self, data, horizons=[1, 5, 10, 20]):
        """Calcule les returns futurs pour diffÃ©rents horizons"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                returns = []

                for horizon in horizons:
                    # Calcul du return futur
                    future_return = data["close"].shift(-horizon) / data["close"] - 1
                    returns.append(future_return)

                    # Calcul de la volatilitÃ© future
                    future_volatility = data["close"].rolling(window=horizon).std().shift(-horizon)
                    returns.append(future_volatility)

                    # Calcul du volume futur normalisÃ©
                    future_volume = (data["volume"].shift(-horizon) / data["volume"]).rolling(window=horizon).mean()
                    returns.append(future_volume)

                    return np.column_stack(returns)

                        except Exception as e:
                            logger.error(f"[{current_time}] Erreur calcul returns futurs: {e}")
                            return np.array([])
    def _save_models(self):
        """Sauvegarde les modÃ¨les entraÃ®nÃ©s"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                # CrÃ©ation du dossier de sauvegarde
                save_dir = os.path.join(current_dir, "models")
                os.makedirs(save_dir, exist_ok=True)

                # Sauvegarde du modÃ¨le hybride
                hybrid_path = os.path.join(save_dir, "hybrid_model.pt")
                torch.save(self.hybrid_model.state_dict(), hybrid_path)

                # Sauvegarde du PPO-GTrXL
                ppo_path = os.path.join(save_dir, "ppo_gtrxl.pt")
                torch.save(self.models["ppo_gtrxl"].state_dict(), ppo_path)

                # Sauvegarde du CNN-LSTM
                cnn_lstm_path = os.path.join(save_dir, "cnn_lstm.pt")
                torch.save(self.models["cnn_lstm"].state_dict(), cnn_lstm_path)

                # Sauvegarde des mÃ©tadonnÃ©es
                metadata = {
                "timestamp": current_time,
                "user": self.current_user,
                "model_versions": {
                "hybrid": self.hybrid_model.version,
                "ppo_gtrxl": self.models["ppo_gtrxl"].version,
                "cnn_lstm": self.models["cnn_lstm"].version
                },
                "training_metrics": self._get_training_metrics()
                }

                metadata_path = os.path.join(save_dir, "metadata.json")
                with open(metadata_path, "w") as f:
                    json.dump(metadata, f, indent=4)

                    logger.info(f"[{current_time}] âœ… ModÃ¨les sauvegardÃ©s avec succÃ¨s")

                        except Exception as e:
                            logger.error(f"[{current_time}] âŒ Erreur sauvegarde modÃ¨les: {e}")
                            raise

    def _get_training_metrics(self):
        """RÃ©cupÃ¨re les mÃ©triques d'entraÃ®nement"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                metrics = {
                "hybrid_model": {
                "loss": self.hybrid_model.training_history["loss"],
                "val_loss": self.hybrid_model.training_history["val_loss"],
                "accuracy": self.hybrid_model.training_history["accuracy"]
                },
                "ppo_gtrxl": {
                "policy_loss": self.models["ppo_gtrxl"].training_info["policy_loss"],
                "value_loss": self.models["ppo_gtrxl"].training_info["value_loss"],
                "entropy": self.models["ppo_gtrxl"].training_info["entropy"]
                },
                "cnn_lstm": {
                "loss": self.models["cnn_lstm"].history["loss"],
                "val_loss": self.models["cnn_lstm"].history["val_loss"],
                "mae": self.models["cnn_lstm"].history["mae"]
                }
                }

                return metrics

                    except Exception as e:
                        logger.error(f"[{current_time}] Erreur rÃ©cupÃ©ration mÃ©triques: {e}")
                        return {}

    async def _should_stop_trading(self):
        """VÃ©rifie les conditions d'arrÃªt du trading"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                # VÃ©rification du circuit breaker
                    if await self.circuit_breaker.should_stop_trading():
                        logger.warning(f"[{current_time}] Circuit breaker activÃ©")
                        return True

                        # VÃ©rification du drawdown maximum
                        current_drawdown = self.position_manager.calculate_drawdown()
                            if current_drawdown > config["RISK"]["max_drawdown"]:
                                logger.warning(f"[{current_time}] Drawdown maximum atteint: {current_drawdown:.2%}")
                                return True

                                # VÃ©rification de la perte journaliÃ¨re
                                daily_loss = self.position_manager.calculate_daily_loss()
                                    if daily_loss > config["RISK"]["daily_stop_loss"]:
                                        logger.warning(f"[{current_time}] Stop loss journalier atteint: {daily_loss:.2%}")
                                        return True

                                        # VÃ©rification des conditions de marchÃ©
                                        market_conditions = await self._check_market_conditions()
                                            if not market_conditions["safe_to_trade"]:
                                                logger.warning(f"[{current_time}] Conditions de marchÃ© dangereuses: {market_conditions['reason']}")
                                                return True

                                                return False

                                                    except Exception as e:
                                                        logger.error(f"[{current_time}] Erreur vÃ©rification conditions d'arrÃªt: {e}")
                                                        return True  # Par sÃ©curitÃ©

    async def _check_market_conditions(self):
        """VÃ©rifie les conditions de marchÃ©"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                conditions = {
                "safe_to_trade": True,
                "reason": None
                }

                # VÃ©rification de la volatilitÃ©
                volatility = self._analyze_volatility()
                    if volatility["current"] > volatility["threshold"] * 2:
                        conditions["safe_to_trade"] = False
                        conditions["reason"] = "VolatilitÃ© excessive"
                        return conditions

                        # VÃ©rification de la liquiditÃ©
                        liquidity = await self._analyze_market_liquidity()
                            if liquidity["status"] == "insufficient":
                                conditions["safe_to_trade"] = False
                                conditions["reason"] = "LiquiditÃ© insuffisante"
                                return conditions

                                # VÃ©rification des news Ã  haut risque
                                    if await self._check_high_risk_news():
                                        conditions["safe_to_trade"] = False
                                        conditions["reason"] = "News Ã  haut risque"
                                        return conditions

                                        # VÃ©rification des conditions techniques
                                        technical_check = self._check_technical_conditions()
                                            if not technical_check["safe"]:
                                                conditions["safe_to_trade"] = False
                                                conditions["reason"] = technical_check["reason"]
                                                return conditions

                                                return conditions

                                                    except Exception as e:
                                                        logger.error(f"[{current_time}] Erreur vÃ©rification conditions marchÃ©: {e}")
                                                        return {"safe_to_trade": False, "reason": "Erreur systÃ¨me"}
    async def _analyze_market_liquidity(self):
        """Analyse dÃ©taillÃ©e de la liquiditÃ© du marchÃ©"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                liquidity_status = {
                "status": "sufficient",
                "metrics": {},
                "timestamp": current_time
                }

                # Analyse du carnet d'ordres
                for pair in config["TRADING"]["pairs"]:
                    orderbook = self.buffer.get_orderbook(pair)
                        if orderbook:
                            # Profondeur de marchÃ©
                            depth = self._calculate_market_depth(orderbook)

                            # Ratio bid/ask
                            bid_ask_ratio = self._calculate_bid_ask_ratio(orderbook)

                            # Spread moyen
                            avg_spread = self._calculate_average_spread(orderbook)

                            # RÃ©sistance Ã  l'impact
                            impact_resistance = self._calculate_impact_resistance(orderbook)

                            liquidity_status["metrics"][pair] = {
                            "depth": depth,
                            "bid_ask_ratio": bid_ask_ratio,
                            "avg_spread": avg_spread,
                            "impact_resistance": impact_resistance
                            }

                            # VÃ©rification des seuils
                                if (depth < 100000 or  # Exemple de seuil
                                abs(1 - bid_ask_ratio) > 0.2 or
                                avg_spread > 0.001 or
                                impact_resistance < 0.5):
                                    liquidity_status["status"] = "insufficient"

                                    return liquidity_status

                                        except Exception as e:
                                            logger.error(f"[{current_time}] Erreur analyse liquiditÃ©: {e}")
                                            return {"status": "insufficient", "metrics": {}, "timestamp": current_time}

    def _check_technical_conditions(self):
        """VÃ©rifie les conditions techniques du marchÃ©"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                conditions = {
                "safe": True,
                "reason": None,
                "details": {}
                }

                for pair in config["TRADING"]["pairs"]:
                    pair_data = self.buffer.get_latest_ohlcv(pair)

                    # VÃ©rification des divergences
                    divergences = self._check_divergences(pair_data)
                        if divergences["critical"]:
                            conditions["safe"] = False
                            conditions["reason"] = f"Divergence critique sur {pair}"
                            conditions["details"][pair] = divergences
                            return conditions

                            # VÃ©rification des patterns critiques
                            patterns = self._check_critical_patterns(pair_data)
                                if patterns["detected"]:
                                    conditions["safe"] = False
                                    conditions["reason"] = f"Pattern critique sur {pair}: {patterns['pattern']}"
                                    conditions["details"][pair] = patterns
                                    return conditions

                                    # VÃ©rification des niveaux clÃ©s
                                    levels = self._check_key_levels(pair_data)
                                        if levels["breach"]:
                                            conditions["safe"] = False
                                            conditions["reason"] = f"Rupture niveau clÃ© sur {pair}"
                                            conditions["details"][pair] = levels
                                            return conditions

                                            conditions["details"][pair] = {
                                            "divergences": divergences,
                                            "patterns": patterns,
                                            "levels": levels
                                            }

                                            return conditions

                                                except Exception as e:
                                                    logger.error(f"[{current_time}] Erreur vÃ©rification technique: {e}")
                                                    return {"safe": False, "reason": "Erreur systÃ¨me", "details": {}}

    def _check_divergences(self, data):
        """DÃ©tecte les divergences entre prix et indicateurs"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                divergences = {
                "critical": False,
                "types": [],
                "timestamp": current_time
                }

                # RSI Divergence
                rsi = self._calculate_rsi(data)
                    if rsi:
                        price_peaks = self._find_peaks(data["close"])
                        rsi_peaks = self._find_peaks(rsi["value"])

                            if self._is_bearish_divergence(price_peaks, rsi_peaks):
                                divergences["critical"] = True
                                divergences["types"].append("RSI_BEARISH")

                                    if self._is_bullish_divergence(price_peaks, rsi_peaks):
                                        divergences["types"].append("RSI_BULLISH")

                                        # MACD Divergence
                                        macd = self._calculate_macd(data)
                                            if macd:
                                                price_peaks = self._find_peaks(data["close"])
                                                macd_peaks = self._find_peaks(macd["histogram"])

                                                    if self._is_bearish_divergence(price_peaks, macd_peaks):
                                                        divergences["critical"] = True
                                                        divergences["types"].append("MACD_BEARISH")

                                                            if self._is_bullish_divergence(price_peaks, macd_peaks):
                                                                divergences["types"].append("MACD_BULLISH")

                                                                return divergences

                                                                    except Exception as e:
                                                                        logger.error(f"[{current_time}] Erreur dÃ©tection divergences: {e}")
                                                                        return {"critical": False, "types": [], "timestamp": current_time}

    def _check_critical_patterns(self, data):
        """DÃ©tecte les patterns techniques critiques"""
        current_time = "2025-06-09 03:47:46"  # Mise Ã  jour timestamp

            try:
                patterns = {
                "detected": False,
                "pattern": None,
                "confidence": 0,
                "timestamp": current_time
                }

                # Head and Shoulders
                    if self._detect_head_shoulders(data):
                        patterns["detected"] = True
                        patterns["pattern"] = "HEAD_AND_SHOULDERS"
                        patterns["confidence"] = 0.85
                        return patterns

                        # Double Top/Bottom
                            if self._detect_double_pattern(data):
                                patterns["detected"] = True
                                patterns["pattern"] = "DOUBLE_TOP" if data["close"].iloc[-1] < data["close"].mean() else "DOUBLE_BOTTOM"
                                patterns["confidence"] = 0.80
                                return patterns

                                # Rising/Falling Wedge
                                    if self._detect_wedge(data):
                                        patterns["detected"] = True
                                        patterns["pattern"] = "RISING_WEDGE" if data["close"].iloc[-1] > data["close"].mean() else "FALLING_WEDGE"
                                        patterns["confidence"] = 0.75
                                        return patterns

                                        return patterns

                                            except Exception as e:
                                                logger.error(f"[{current_time}] Erreur dÃ©tection patterns: {e}")
                                                return {"detected": False, "pattern": None, "confidence": 0, "timestamp": current_time}

    def run_trading_bot():
        """Point d'entrÃ©e synchrone pour le bot de trading"""
            try:
                # Interface Streamlit
                st.title("Trading Bot Ultimate v4 ğŸ¤–")

                # Informations de session
                st.sidebar.info(f"""
                **Session Info**
                - User: {os.getenv('CURRENT_USER', 'Patmoorea')}
                - Time: {os.getenv('CURRENT_TIME', '2025-06-09 01:27:35')} UTC
                """)

                # Configuration trading
                with st.sidebar:
                    st.header("Trading Configuration")
                    risk_level = st.select_slider(
                    "Risk Level",
                    options=["Low", "Medium", "High"],
                    value="Medium"
                    )
                    pairs = st.multiselect(
                    "Trading Pairs",
                    options=config["TRADING"]["pairs"],
                    default=config["TRADING"]["pairs"]
                    )

                    # Stats en temps rÃ©el
                        try:
                            bot = TradingBotM4()
                            portfolio = asyncio.run(bot.get_real_portfolio())

                            col1, col2, col3 = st.columns(3)
                                if portfolio:
                                    with col1:
                                        st.metric(
                                        "Portfolio Value",
                                        f"{portfolio['total_value']:.2f} USDC",
                                        f"{sum(p['pnl'] for p in portfolio['positions']):+.2f} USDC"
                                        )
                                        with col2:
                                            st.metric(
                                            "Active Positions",
                                            str(len(portfolio['positions']))
                                            )
                                            with col3:
                                                total_pnl = sum(p['pnl'] for p in portfolio['positions'])
                                                pnl_percent = (total_pnl / portfolio['total_value'] * 100) if portfolio['total_value'] > 0 else 0
                                                st.metric(
                                                "24h P&L",
                                                f"{total_pnl:+.2f} USDC",
                                                f"{pnl_percent:+.2f}%"
                                                )
                                                    else:
                                                        with col1:
                                                            st.metric("Portfolio Value", "10,000 USDC", "+5.2%")
                                                            with col2:
                                                                st.metric("Active Positions", "2", "Open")
                                                                with col3:
                                                                    st.metric("24h P&L", "+123 USDC", "+1.23%")
                                                                        except Exception as e:
                                                                            logger.error(f"Erreur rÃ©cupÃ©ration portfolio: {e}")
                                                                            st.error("Erreur lors de la rÃ©cupÃ©ration des donnÃ©es du portfolio")

                                                                            # Bouton de dÃ©marrage
                                                                                if st.button("Start Trading Bot", type="primary"):
                                                                                        try:
                                                                                            loop = asyncio.new_event_loop()
                                                                                            asyncio.set_event_loop(loop)

                                                                                            with st.spinner("Initializing trading bot..."):
                                                                                                bot = TradingBotM4()
                                                                                                loop.run_until_complete(bot.run())
                                                                                                    except Exception as e:
                                                                                                        st.error(f"Bot error: {str(e)}")
                                                                                                        logging.error("Bot error", exc_info=True)
                                                                                                            finally:
                                                                                                                loop.close()

                                                                                                                    except Exception as e:
                                                                                                                        st.error(f"Critical error: {str(e)}")
                                                                                                                        logging.error("Fatal error", exc_info=True)

                                                                                                                            if __name__ == "__main__":
                                                                                                                                # Configuration du logging
                                                                                                                                logging.basicConfig(
                                                                                                                                level=logging.INFO,
                                                                                                                                format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                                                                                                                                handlers=[
                                                                                                                                logging.FileHandler('trading_bot.log'),
                                                                                                                                logging.StreamHandler()
                                                                                                                                ]
                                                                                                                                )
                                                                                                                                logger = logging.getLogger(__name__)

                                                                                                                                # Configuration de l'event loop au dÃ©marrage
                                                                                                                                setup_event_loop()

                                                                                                                                # Lancement de l'application
                                                                                                                                run_trading_bot()

                                                                                                                                # Update des variables d'environnement sans modifier les existantes
                                                                                                                                    if 'CURRENT_TIME' not in os.environ:
                                                                                                                                        os.environ['CURRENT_TIME'] = "2025-06-09 00:39:01"
                                                                                                                                            if 'CURRENT_USER' not in os.environ:
                                                                                                                                                os.environ['CURRENT_USER'] = "Patmoorea"

                                                                                                                                                # Ajout des mÃ©thodes de trading rÃ©el Ã  la classe TradingBotM4
    async def setup_real_exchange(self):
        """Configuration sÃ©curisÃ©e de l'exchange"""
            if not hasattr(self, 'exchange') or self.exchange is None:
                    try:
                        self.exchange = ccxt.binance({
                        'apiKey': os.getenv('BINANCE_API_KEY'),
                        'secret': os.getenv('BINANCE_API_SECRET'),
                        'enableRateLimit': True
                        })
                        await self.exchange.load_markets()
                        logger.info("Exchange configurÃ© avec succÃ¨s")
                        return True
                            except Exception as e:
                                logger.error(f"Erreur configuration exchange: {e}")
                                return False

    async def setup_real_telegram(self):
        """Configuration sÃ©curisÃ©e de Telegram"""
            if not hasattr(self, 'telegram') or self.telegram is None:
                    try:
                        self.telegram = telegram.Bot(token=os.getenv('TELEGRAM_BOT_TOKEN'))
                        self.chat_id = os.getenv('TELEGRAM_CHAT_ID')
                        await self.telegram.send_message(
                        chat_id=self.chat_id,
                        text=f"ğŸ¤– Bot connectÃ©\nDate: {self.current_time}\nTrader: {self.current_user}"
                        )
                        return True
                            except Exception as e:
                                logger.error(f"Erreur configuration Telegram: {e}")
                                return False

    async def get_real_portfolio(self):
        """RÃ©cupÃ©ration sÃ©curisÃ©e du portfolio"""
            try:
                balance = await self.exchange.fetch_balance()
                positions = await self.exchange.fetch_positions()

                portfolio = {
                'total_value': float(balance['total'].get('USDC', 0)),
                'free': float(balance['free'].get('USDC', 0)),
                'used': float(balance['used'].get('USDC', 0)),
                'positions': [
                {
                'symbol': pos['symbol'],
                'size': pos['contracts'],
                'value': pos['notional'],
                'pnl': pos['unrealizedPnl']
                }
                for pos in positions if pos['contracts'] > 0
                ]
                }

                await self.telegram.send_message(
                chat_id=self.chat_id,
                text=f"""ğŸ’° Portfolio Update:
                    Total: {portfolio['total_value']:.2f} USDC
                    Positions: {len(portfolio['positions'])}
                    PnL: {sum(p['pnl'] for p in portfolio['positions']):.2f} USDC"""
                    )

                    return portfolio

                        except Exception as e:
                            logger.error(f"Erreur portfolio: {e}")
                            return None

    async def execute_real_trade(self, signal):
        """ExÃ©cution sÃ©curisÃ©e des trades"""
            try:
                # VÃ©rification du solde
                balance = await self.get_real_portfolio()
                    if not balance or balance['free'] < signal['amount'] * signal['price']:
                        logger.warning("Solde insuffisant pour le trade")
                        return None

                        # Calcul stop loss et take profit
                        stop_loss = signal['price'] * (1 - signal['risk_ratio'])
                        take_profit = signal['price'] * (1 + signal['risk_ratio'] * 2)

                        # Placement de l'ordre
                        order = await self.exchange.create_order(
                        symbol=signal['symbol'],
                        type='limit',
                        side=signal['side'],
                        amount=signal['amount'],
                        price=signal['price'],
                        params={
                        'stopLoss': {
                        'type': 'trailing',
                        'stopPrice': stop_loss,
                        'callbackRate': 1.0
                        },
                        'takeProfit': {
                        'price': take_profit
                        }
                        }
                        )

                        # Notification
                        await self.telegram.send_message(
                        chat_id=self.chat_id,
                        text=f"""ğŸ”µ Nouvel ordre:
                            Symbol: {order['symbol']}
                            Type: {order['type']}
                            Side: {order['side']}
                            Amount: {order['amount']}
                            Prix: {order['price']}
                            Stop Loss: {stop_loss}
                            Take Profit: {take_profit}"""
                            )

                            return order

                                except Exception as e:
                                    logger.error(f"Erreur trade: {e}")
                                    return None

                                    # Extension sÃ©curisÃ©e de la mÃ©thode run() existante
    async def run_real_trading(self):
        """Boucle de trading rÃ©el sÃ©curisÃ©e"""
            try:
                # Initialisation des connexions rÃ©elles
                    if not await self.setup_real_exchange():
                        raise Exception("Ã‰chec configuration exchange")

                            if not await self.setup_real_telegram():
                                raise Exception("Ã‰chec configuration Telegram")

                                # DÃ©marrage du bot
                                logger.info(f"""
                                â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
                                â•‘                Trading Bot Ultimate v4 - REAL               â•‘
                                â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
                                â•‘ Time: {self.current_time} UTC                              â•‘
                                â•‘ User: {self.current_user}                                  â•‘
                                â•‘ Mode: REAL TRADING                                         â•‘
                                â•‘ Status: RUNNING                                            â•‘
                                â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                                """)

                                # Premier check du portfolio
                                initial_portfolio = await self.get_real_portfolio()
                                    if not initial_portfolio:
                                        raise Exception("Impossible de rÃ©cupÃ©rer le portfolio")

                                        # Boucle principale existante avec trading rÃ©el
                                        while True:
                                                try:
                                                    # Analyse et dÃ©cision depuis le code existant
                                                    decision = await self.analyze_signals(
                                                    await self.get_latest_data(),
                                                    await self.calculate_indicators()
                                                    )

                                                        if decision and decision.get('should_trade', False):
                                                            # ExÃ©cution rÃ©elle
                                                            trade_result = await self.execute_real_trade(decision)
                                                                if trade_result:
                                                                    logger.info(f"Trade exÃ©cutÃ©: {trade_result['id']}")

                                                                    # Mise Ã  jour portfolio
                                                                    await self.get_real_portfolio()

                                                                    # DÃ©lai avant prochaine itÃ©ration
                                                                    await asyncio.sleep(1)

                                                                        except Exception as e:
                                                                            logger.error(f"Erreur dans la boucle: {e}")
                                                                            continue

                                                                            except Exception as e:
                                                                                logger.error(f"Erreur fatale: {e}")
                                                                                    if hasattr(self, 'telegram'):
                                                                                        await self.telegram.send_message(
                                                                                        chat_id=self.chat_id,
                                                                                        text=f"ğŸš¨ Erreur critique - Bot arrÃªtÃ©: {str(e)}"
                                                                                        )
                                                                                        raise

                                                                                        # Classe pour gÃ©rer le portfolio rÃ©el
class RealPortfolio:
    def __init__(self):
        self.current_time = "2025-06-09 03:47:46"
        self.current_user = "Patmoorea"
        self.portfolio_value = 0.0
        self.positions_count = 0
        self.daily_pnl = 0.0

    async def update(self, exchange):
            try:
                balance = await exchange.fetch_balance()
                positions = await exchange.fetch_positions()

                self.portfolio_value = float(balance['total'].get('USDC', 0))
                self.positions_count = len([p for p in positions if p['contracts'] > 0])
                self.daily_pnl = sum([p['unrealizedPnl'] for p in positions])

                return True
                    except Exception as e:
                        logger.error(f"Erreur mise Ã  jour portfolio: {e}")
                        return False

                        # Modification de la fonction update_dashboard pour utiliser les vraies donnÃ©es
    async def update_real_dashboard(self):
            try:
                portfolio = RealPortfolio()
                    if await portfolio.update(self.exchange):
                        col1, col2, col3 = st.columns(3)
                        with col1:
                            st.metric(
                            "Portfolio Value",
                            f"{portfolio.portfolio_value:.2f} USDC",
                            f"{portfolio.daily_pnl:+.2f} USDC"
                            )
                            with col2:
                                st.metric(
                                "Active Positions",
                                str(portfolio.positions_count)
                                )
                                with col3:
                                    pnl_percent = (portfolio.daily_pnl / portfolio.portfolio_value * 100) if portfolio.portfolio_value > 0 else 0
                                    st.metric(
                                    "24h P&L",
                                    f"{portfolio.daily_pnl:+.2f} USDC",
                                    f"{pnl_percent:+.2f}%"
                                    )
                                        except Exception as e:
                                            logger.error(f"Erreur mise Ã  jour dashboard: {e}")
                                            st.error(f"Erreur mise Ã  jour mÃ©triques: {str(e)}")

    def _initialize_analyzers(self):
        """Initialize all analysis components"""
        # 1. Initialisation des classes d'indicateurs
        self.advanced_indicators = AdvancedIndicators()
        self.momentum_indicators = MomentumIndicators()
        self.volatility_indicators = VolatilityIndicators()
        self.volume_analysis = VolumeAnalysis()
        self.orderflow_analysis = OrderFlowAnalysis(
        config=OrderFlowConfig(tick_size=0.1)
        )
        self.trend_indicators = TrendIndicators()

        # 2. Configuration des indicateurs utilisÃ©s par le bot
        self.indicators = {
        "trend": {
        # Indicateurs de tendance
        "supertrend": self.trend_indicators.supertrend,        # Depuis TrendIndicators
        "ichimoku": self.trend_indicators.ichimoku,            # Depuis TrendIndicators
        "vwma": self.trend_indicators.vwma,                    # Depuis TrendIndicators
        "ema_ribbon": self.trend_indicators.ema_ribbon,        # Depuis TrendIndicators
        "parabolic_sar": self.trend_indicators.psar,          # Depuis TrendIndicators
        "zigzag": self.trend_indicators.trix                   # Depuis TrendIndicators
        },
        "momentum": {
        # Indicateurs de momentum
        "rsi": self.momentum_indicators.rsi,                   # Depuis MomentumIndicators
        "stoch_rsi": self.momentum_indicators.stochastic_rsi,  # Depuis MomentumIndicators
        "macd": self.momentum_indicators.macd,                 # Depuis MomentumIndicators
        "awesome": self.momentum_indicators.awesome_oscillator, # Depuis MomentumIndicators
        "momentum": self.momentum_indicators.williams_r,       # Depuis MomentumIndicators
        "tsi": self.momentum_indicators.cci                    # Depuis MomentumIndicators
        },
        "volatility": {
        # Indicateurs de volatilitÃ©
        "bbands": self.volatility_indicators.bollinger_bands,  # Depuis VolatilityIndicators
        "keltner": self.volatility_indicators.keltner_channels,# Depuis VolatilityIndicators
        "atr": self.volatility_indicators.atr,                # Depuis VolatilityIndicators
        "vix_fix": self.volatility_indicators.volatility_index,# Depuis VolatilityIndicators
        "natr": self.volatility_indicators.parkinson,         # Depuis VolatilityIndicators
        "true_range": self.volatility_indicators.yang_zhang   # Depuis VolatilityIndicators
        },
        "volume": {
        # Indicateurs de volume
        "obv": self.volume_analysis.on_balance_volume,        # Depuis VolumeAnalysis
        "vwap": self.volume_analysis.vwap,                    # Depuis VolumeAnalysis
        "acc_dist": self.volume_analysis.accumulation_distribution, # Depuis VolumeAnalysis
        "chaikin_money": self.volume_analysis.chaikin_money_flow, # Depuis VolumeAnalysis
        "ease_move": self.volume_analysis.ease_of_movement,   # Depuis VolumeAnalysis
        "volume_profile": self.volume_analysis.volume_profile # Depuis VolumeAnalysis
        },
        "orderflow": {
        # Indicateurs d'orderflow
        "delta": self.orderflow_analysis.delta_volume,        # Depuis OrderFlowAnalysis
        "cvd": self.orderflow_analysis.analyze_imbalance,     # Depuis OrderFlowAnalysis
        "footprint": self.orderflow_analysis.create_footprint,# Depuis OrderFlowAnalysis
        "liquidity": self.orderflow_analysis.analyze_liquidity,# Depuis OrderFlowAnalysis
        "imbalance": self.orderflow_analysis.analyze_orderflow,# Depuis OrderFlowAnalysis
        "absorption": self.orderflow_analysis.absorption_ratio # Depuis OrderFlowAnalysis
        }
        }

        # 3. Initialisation des modÃ¨les d'IA
        self.models = {
        "cnn_lstm": CNNLSTM(
        input_size=42,  # Nombre total d'indicateurs
        hidden_size=256,
        num_layers=3,
        dropout=config["AI"]["dropout"]
        ),
        "ppo_gtrxl": PPOGTrXL(
        state_dim=42 * len(config["TRADING"]["timeframes"]),  # Indicateurs Ã— Timeframes
        action_dim=len(config["TRADING"]["pairs"]),          # Nombre de paires
        n_layers=config["AI"]["gtrxl_layers"],
        embedding_dim=config["AI"]["embedding_dim"]
        )
        }

    async def get_latest_data(self):
        """RÃ©cupÃ¨re les derniÃ¨res donnÃ©es de marchÃ© pour chaque paire et timeframe"""
            try:
                data = {}
                # Pour chaque paire de trading
                for pair in config["TRADING"]["pairs"]:
                    # Pour chaque timeframe configurÃ©
                    for timeframe in config["TRADING"]["timeframes"]:
                        # RÃ©cupÃ¨re les derniÃ¨res donnÃ©es depuis le buffer
                        data.setdefault(timeframe, {})[pair] = self.buffer.get_latest()
                        return data
                            except Exception as e:
                                logger.error(f"[{datetime.utcnow()}] Erreur get_latest_data: {e}")
                                return None
